# Stubs for pagination (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional, Callable, Dict, Text, Iterator, TypeVar, Awaitable, Coroutine, Iterable

from async_property import async_property

_T = TypeVar('_T')


class RateLimiter:
    _rate_limit: float
    _consumed: float
    _time_of_last_acquire: float
    _time_module: Any
    def __init__(self, rate_limit: float, time_module: Any = ...) -> None: ...
    def consume(self, units: int) -> None: ...
    def acquire(self) -> None: ...
    @property
    def rate_limit(self) -> float: ...
    @rate_limit.setter
    def rate_limit(self, rate_limit: float) -> None: ...


class PageIterator:
    _operation: Callable[[Any], Awaitable[Dict]]
    _args: Any
    _kwargs: Dict[Text, Any]
    _first_iteration: bool
    _total_scanned_count: int
    _rate_limiter: Optional[RateLimiter]
    _last_evaluated_key: dict
    def __init__(self, operation: Any, args: Any, kwargs: Any, rate_limit: Optional[Any] = ...) -> None: ...
    def __aiter__(self) -> Iterator[_T]: ...
    async def __anext__(self) -> _T: ...
    @async_property
    async def key_names(self) -> Iterable[Text]: ...
    @property
    def page_size(self) -> int: ...
    @page_size.setter
    def page_size(self, page_size: int): ...
    @property
    def last_evaluated_key(self) -> Optional[Dict[Text, Dict[Text, Any]]]: ...
    @property
    def total_scanned_count(self) -> int: ...


class ResultIterator(Iterator[_T]):
    page_iter: PageIterator
    _first_iteration: bool
    _map_fn: Optional[Callable]
    _limit: Optional[int]
    _total_count: int
    _items: Any
    _index: int
    _count: int
    def __init__(
        self,
        operation: Callable,
        args: Any,
        kwargs: Dict[Text, Any],
        map_fn: Optional[Callable] = ...,
        limit: Optional[int] = ...,
        rate_limit: Optional[float] = ...,
    ) -> None: ...
    async def _get_next_page(self): ...
    def __aiter__(self) -> Iterator[_T]: ...
    async def __anext__(self) -> _T: ...
    @async_property
    async def last_evaluated_key(self) -> Optional[Dict[Text, Dict[Text, Any]]]: ...
    @property
    def total_count(self) -> int: ...
